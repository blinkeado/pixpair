<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixCrab - Synchronized Photo Capture</title>
    <link rel="stylesheet" href="dist/output.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="firebase-config.js"></script>

    <script>
        // App configuration
        const APP_BASE_URL = 'https://pixcrab.netlify.app';
        
        // Debugging function
        function debugLog(message) {
            const now = new Date();
            const timestamp = now.toLocaleTimeString() + '.' + now.getMilliseconds().toString().padStart(3, '0');
            const debugConsole = document.getElementById('debugConsole');
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            debugConsole.appendChild(logEntry);
            debugConsole.scrollTop = debugConsole.scrollTop = debugConsole.scrollHeight;
            console.log(`[PixCrab] ${message}`);
        }

        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            debugLog("DOM content loaded - initializing application");
            
            // Main app state variables
            let currentUser = null;
            let currentSessionId = null;
            let stream = null;
            let isSessionOwner = false;
            let peers = 0;
            let userId = null;
            let lastCaptureTime = 0;
            let usingFrontCamera = true;
            let participantRef = null;
            let participantsRef = null;
            let hasShownHint = false;
            let touchStartY = 0;
            let touchEndY = 0;
            let qrCode = null;
            let countdownInterval = null;
            
            // DOM elements - defined early to ensure they're available throughout the code
            const sessionSetup = document.getElementById('sessionSetup');
            const cameraSection = document.getElementById('cameraSection');
            const sessionIdInput = document.getElementById('sessionId');
            const joinSessionBtn = document.getElementById('joinSession');
            const createSessionBtn = document.getElementById('createSession');
            const captureBtn = document.getElementById('captureBtn');
            const newSessionBtn = document.getElementById('newSessionBtn');
            const cameraFeed = document.getElementById('cameraFeed');
            const photoResult = document.getElementById('photoResult');
            const connectionStatus = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            const peerCount = document.getElementById('peerCount');
            const countdownOverlay = document.getElementById('countdownOverlay');
            const countdownText = document.getElementById('countdownText');
            const captureText = document.getElementById('captureText');
            const toast = document.getElementById('toast');
            const displaySessionId = document.getElementById('displaySessionId');
            const sessionIdBadge = document.getElementById('sessionIdBadge');
            const imageQualityInfo = document.getElementById('imageQualityInfo');
            const imageSizeSpan = document.getElementById('imageSize');
            const cameraSwitchBtn = document.getElementById('cameraSwitchBtn');
            const slideContainer = document.getElementById('slideContainer');
            const hintText = document.getElementById('hintText');
            const qrContainer = document.getElementById('qrcode');
            const qrFallback = document.getElementById('qrFallback');
            const gallerySection = document.getElementById('gallerySection');
            const signOutBtn = document.getElementById('signOutBtn');
            const googleSignInBtn = document.getElementById('googleSignIn');
            const appleSignInBtn = document.getElementById('appleSignIn');
            const guestSignInBtn = document.getElementById('guestSignIn');
            
            // Disable buttons until Firebase is connected
            if (joinSessionBtn) joinSessionBtn.disabled = true;
            if (createSessionBtn) createSessionBtn.disabled = true;
            if (captureBtn) captureBtn.disabled = true;
            
            // Toggle debug console
            const debugToggle = document.getElementById('debugToggle');
            if (debugToggle) {
                debugToggle.addEventListener('click', () => {
                    debugLog("Debug toggle button clicked");
                    const consoleElem = document.getElementById('debugConsole');
                    consoleElem.style.display = consoleElem.style.display === 'none' ? 'block' : 'none';
                    debugLog(`Debug console ${consoleElem.style.display === 'none' ? 'hidden' : 'shown'}`);
                });
            }

            // Ensure Firebase is initialized and services are available globally
            if (typeof firebase === 'undefined') {
                console.error("Firebase SDK not loaded");
                debugLog("Firebase SDK not loaded");
                return;
            }

            // Initialize Firebase if not already initialized
            if (!firebase.apps.length) {
                try {
                    firebase.initializeApp(firebaseConfig);
                    debugLog("Firebase initialized successfully");
                } catch (error) {
                    debugLog(`Firebase initialization error: ${error.message}`);
                    showToast('Failed to initialize Firebase');
                    console.error("Firebase initialization failed:", error);
                    return;
                }
            }

            // Ensure Firebase services are available globally
            window.auth = firebase.auth();
            window.database = firebase.database();
            window.storage = firebase.storage();
            
            // Test Firebase connection immediately
            database.ref('.info/connected').on('value', (snap) => {
                if (snap.val() === true) {
                    debugLog("Connected to Firebase");
                    // Enable buttons only after Firebase is connected
                    if (joinSessionBtn) joinSessionBtn.disabled = false;
                    if (createSessionBtn) createSessionBtn.disabled = false;
                } else {
                    debugLog("Disconnected from Firebase");
                    // Disable buttons if Firebase is disconnected
                    if (joinSessionBtn) joinSessionBtn.disabled = true;
                    if (createSessionBtn) createSessionBtn.disabled = true;
                }
            });

            // Test database write
            database.ref('test').set({
                timestamp: firebase.database.ServerValue.TIMESTAMP
            }).then(() => {
                debugLog("Test write to Firebase successful");
            }).catch((error) => {
                debugLog(`Test write to Firebase failed: ${error.message}`);
                showToast('Failed to connect to Firebase');
            });

            // Test Firebase connection
            database.ref('.info/connected').on('value', (snap) => {
                if (snap.val() === true) {
                    debugLog("Connected to Firebase");
                } else {
                    debugLog("Disconnected from Firebase");
                }
            });

            // Test database write
            database.ref('test').set({
                timestamp: firebase.database.ServerValue.TIMESTAMP
            }).then(() => {
                debugLog("Test write to Firebase successful");
            }).catch((error) => {
                debugLog(`Test write to Firebase failed: ${error.message}`);
            });
            
            // Initialize countdown overlay state
            function resetCountdownOverlay() {
                countdownOverlay.style.display = 'none';
                countdownOverlay.classList.add('hidden');
                countdownText.style.display = 'none';
                countdownText.classList.add('hidden');
                captureText.style.display = 'none';
                captureText.classList.add('hidden');
                countdownText.textContent = '3';
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
            }

            // Call reset on page load
            resetCountdownOverlay();
            
            // Generate a safe, human-readable session ID using common words
            async function generateSafeSessionId() {
                // Fallback function if word list fetch fails
                const fallbackSessionId = () => {
                    debugLog("Using fallback alphanumeric session ID generation");
                    return Math.random().toString(36).substring(2, 8).toUpperCase();
                };

                try {
                    debugLog("Attempting to fetch word list for session ID generation");
                    
                    // Using a reliable word list from GitHub (MIT license, CORS enabled)
                    const response = await fetch('https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-usa-no-swears-medium.txt');
                    
                    if (!response.ok) {
                        debugLog(`Word list fetch failed with status: ${response.status}`);
                        return fallbackSessionId();
                    }
                    
                    const text = await response.text();
                    const words = text.split('\n')
                        .filter(word => word.length >= 3 && word.length <= 5) // 3-5 letter words
                        .filter(word => /^[a-z]+$/.test(word)); // Only alphabetic words
                    
                    if (words.length === 0) {
                        debugLog("Word list is empty after filtering");
                        return fallbackSessionId();
                    }
                    
                    // Select a random word from the filtered list
                    const randomWord = words[Math.floor(Math.random() * words.length)];
                    const randomNumber = Math.floor(Math.random() * 900) + 100; // 100-999
                    
                    // Format: lowercase word + 3-digit number (e.g., "apple123")
                    const sessionId = `${randomWord.toLowerCase()}${randomNumber}`;
                    
                    debugLog(`Generated human-readable session ID: ${sessionId}`);
                    return sessionId;
                    
                } catch (error) {
                    debugLog(`Error fetching word list: ${error.message}`);
                    return fallbackSessionId();
                }
            }
            
            // Generate a random user ID
            function generateUserId() {
                return 'user_' + Math.random().toString(36).substring(2, 9);
            }
            
            // Show toast message
            function showToast(message) {
                debugLog(`Toast: ${message}`);
                toast.textContent = message;
                toast.classList.remove('hidden');
                setTimeout(() => {
                    toast.classList.add('hidden');
                }, 3000);
            }
            
            // Show hint message
            function showHint() {
                if (hasShownHint) return;
                
                hintText.style.opacity = '1';
                setTimeout(() => {
                    hintText.style.opacity = '0';
                    hasShownHint = true;
                }, 2000);
                
                debugLog("Hint shown");
            }
            
            // Generate QR code for session using centralized base URL
            function generateQRCode(sessionId) {
                debugLog(`Generating QR code for session: ${sessionId}`);
                
                // Clear previous QR code if exists
                if (qrCode) {
                    qrCode.clear();
                    qrCode = null;
                }
                
                qrContainer.innerHTML = '';
                qrFallback.classList.add('hidden');
                
                // Use the current page URL as base,
const sessionUrl = `${APP_BASE_URL}?sessionId=${sessionId}`;

                
                debugLog(`QR will encode: ${sessionUrl}`);

                try {
                    qrCode = new QRCode(qrContainer, {
                        text: sessionUrl,
                        width: 184,
                        height: 184,
                        colorDark: "#4831D4",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.H
                    });
                    
                    qrContainer.classList.remove('hidden');
                    debugLog("QR code generated successfully");
                } catch (err) {
                    debugLog(`QR code generation failed: ${err.message}`);
                    // Fallback: show session ID
                    qrFallback.textContent = sessionId;
                    qrFallback.classList.remove('hidden');
                    qrContainer.classList.remove('hidden');
                }
            }
            
            // Initialize camera
            async function initCamera() {
                try {
                    debugLog("Initializing camera...");
                    
                    if (stream) {
                        stopCamera();
                    }
                    
                    const constraints = {
                        video: { 
                            facingMode: usingFrontCamera ? 'user' : { exact: 'environment' },
                            width: { ideal: 2560 },
                            height: { ideal: 1440 },
                            aspectRatio: 0.75
                        },
                        audio: false
                    };
                    
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    cameraFeed.srcObject = stream;
                    
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    if (videoDevices.length > 1) {
                        cameraSwitchBtn.classList.remove('hidden');
                    }
                    
                    debugLog("Camera initialized successfully");
                } catch (err) {
                    debugLog(`Camera error: ${err.message}`);
                    showToast('Could not access camera. Please allow camera permissions.');
                }
            }
            
            // Stop camera
            function stopCamera() {
                if (stream) {
                    debugLog("Stopping camera...");
                    stream.getTracks().forEach(track => track.stop());
                    cameraFeed.srcObject = null;
                    stream = null;
                }
            }
            
            // Switch between front and rear cameras
            async function switchCamera() {
                debugLog(`Switching to ${usingFrontCamera ? 'rear' : 'front'} camera`);
                usingFrontCamera = !usingFrontCamera;
                await initCamera();
            }
            
            // Start synchronized countdown
            function startCountdown(captureTime) {
                debugLog(`Starting countdown for capture at ${new Date(captureTime).toISOString()}`);
                
                const now = Date.now();
                const timeUntilCapture = captureTime - now;
                
                if (timeUntilCapture <= 0) {
                    debugLog("Capture time already passed, taking photo immediately");
                    takePhoto();
                    return;
                }
                
                // Reset countdown state before starting new countdown
                resetCountdownOverlay();
                
                // Show countdown overlay
                countdownOverlay.style.display = 'flex';
                countdownOverlay.classList.remove('hidden');
                countdownText.style.display = 'block';
                countdownText.classList.remove('hidden');
                debugLog("Countdown overlay shown");
                
                const countdownSteps = Math.floor(timeUntilCapture / 1000);
                let currentCount = countdownSteps;
                
                countdownText.textContent = currentCount;
                debugLog(`Countdown started: ${currentCount} seconds remaining`);
                
                countdownInterval = setInterval(() => {
                    currentCount--;
                    
                    if (currentCount > 0) {
                        countdownText.textContent = currentCount;
                        debugLog(`Countdown: ${currentCount}`);
                    } else {
                        countdownText.style.display = 'none';
                        countdownText.classList.add('hidden');
                        captureText.style.display = 'block';
                        captureText.classList.remove('hidden');
                        debugLog("Countdown: Capture!");
                    }
                }, 1000);
                
                setTimeout(() => {
                    debugLog("Countdown complete, taking photo...");
                    resetCountdownOverlay();
                    takePhoto();
                }, timeUntilCapture);
            }
            
            // Take photo at the exact synchronized time
            function takePhoto() {
                if (!stream) {
                    debugLog("Cannot take photo - no camera stream");
                    return;
                }
                
                debugLog("Taking photo...");
                
                const canvas = document.createElement('canvas');
                const targetWidth = 2160;
                const targetHeight = 1920;
                
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                
                const ctx = canvas.getContext('2d');
                
                const sourceAspect = cameraFeed.videoWidth / cameraFeed.videoHeight;
                const targetAspect = targetWidth / targetHeight;
                
                let sourceWidth, sourceHeight, sourceX, sourceY;
                
                if (sourceAspect > targetAspect) {
                    sourceHeight = cameraFeed.videoHeight;
                    sourceWidth = sourceHeight * targetAspect;
                    sourceX = (cameraFeed.videoWidth - sourceWidth) / 2;
                    sourceY = 0;
                } else {
                    sourceWidth = cameraFeed.videoWidth;
                    sourceHeight = sourceWidth / targetAspect;
                    sourceX = 0;
                    sourceY = (cameraFeed.videoHeight - sourceHeight) / 2;
                }
                
                ctx.drawImage(
                    cameraFeed, 
                    sourceX, sourceY, sourceWidth, sourceHeight,
                    0, 0, targetWidth, targetHeight
                );
                
                photoResult.src = canvas.toDataURL('image/jpeg', 0.95);
                photoResult.onload = () => {
                    photoResult.style.display = 'block';
                    cameraFeed.style.display = 'none';
                    cameraSection.classList.add('shutter-effect');
                    setTimeout(() => {
                        cameraSection.classList.remove('shutter-effect');
                        // Return to camera view after shutter effect (important fix)
                        setTimeout(() => {
                            photoResult.style.display = 'none';
                            cameraFeed.style.display = 'block';
                        }, 1000);
                    }, 500);
                };
                
                debugLog("Photo taken and displayed");
                
                uploadPhoto(canvas.toDataURL('image/jpeg', 0.95));
            }
            
            // Upload photo to Firebase
            function uploadPhoto(photoData) {
              if (!currentUser) {
                debugLog("Cannot upload photo - no user signed in");
                return;
              }

              if (!currentSessionId) {
                debugLog("Cannot upload photo - no active session");
                return;
              }

              const userId    = currentUser.uid;
              const photoId   = Date.now().toString();
              const isGuest   = currentUser.isAnonymous;
              const sessionId = currentSessionId;

              debugLog(`Uploading photo for user ${userId} in session ${sessionId}`);

              const storageRef = storage.ref(`users/${userId}/${photoId}.jpg`);
              const backupRef  = isGuest
                ? storage.ref(`analysisData/guests/${userId}/${photoId}.jpg`)
                : null;

              fetch(photoData)
                .then(res => res.blob())
                .then(blob => {
                  const fileSize = blob.size;
                  debugLog(`Photo size: ${Math.round(fileSize/1024)} KB`);

                  // 1) Upload to Firebase Storage
                  return storageRef.put(blob)
                    .then(() => {
                      debugLog("Photo uploaded to Firebase Storage");
                      if (isGuest && backupRef) {
                        debugLog("Creating backup for guest user");
                        return backupRef.put(blob);
                      }
                    })
                    // 2) Save metadata
                    .then(() => {
                      debugLog("Saving photo metadata");
                      return collectAndSaveMetadata(sessionId, photoId, fileSize);
                    })
                    // 3) Get download URL and save to session
                    .then(() => {
                      debugLog("Getting photo download URL");
                      return storageRef.getDownloadURL();
                    })
                    .then(url => {
                      debugLog(`Saving photo URL to session ${sessionId}`);
                      return database.ref(`sessions/${sessionId}/photos/${userId}`).set({
                        photoData: url,
                        timestamp: firebase.database.ServerValue.TIMESTAMP,
                        userId: userId
                      });
                    });
                })
                .then(() => {
                  debugLog("Photo upload complete: storage ✓ metadata ✓ session ✓");
                  showToast('Photo saved to your account');
                })
                .catch(error => {
                  debugLog(`Photo upload error: ${error.message}`);
                  console.error("Photo upload error:", error);
                  showToast('Failed to save photo');
                });
            }




 // 🔧 Esta función recopila y guarda todos los metadatos posibles en Firebase Realtime Database
async function collectAndSaveMetadata(sessionId, photoId, fileSize) {
const metadata = {
    timestamp: Date.now(),
    sessionId: sessionId,
    photoId: photoId,
    size: fileSize, // ✅ Esta es la línea nueva que debes insertar
    ipInfo: window._geoip || null,
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    language: navigator.language,
    languages: navigator.languages,
    screen: {
        width: screen.width,
        height: screen.height,
        pixelRatio: window.devicePixelRatio
    },
    viewport: {
        width: window.innerWidth,
        height: window.innerHeight
    },
    hardware: {
        cores: navigator.hardwareConcurrency,
        touchPoints: navigator.maxTouchPoints
    },
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    localTime: new Date().toLocaleString(),
    network: navigator.connection ? {
        type: navigator.connection.type,
        effectiveType: navigator.connection.effectiveType,
        downlink: navigator.connection.downlink,
        rtt: navigator.connection.rtt
    } : null,
    page: {
        referrer: document.referrer,
        url: window.location.href
    },
    context: {
        isMobile: /Mobi|Android/i.test(navigator.userAgent),
        isGuest: currentUser?.isAnonymous || false
    }
};


    const userId = currentUser?.uid || 'unknown_user';
    await database.ref(`users/${userId}/photos/${photoId}/metadata`).set(metadata);
}

            
            // Combine photos vertically with consistent size (2160x3840 - 9:16 aspect ratio)
            function combinePhotosSimple(photo1, photo2) {
                debugLog("Starting simple photo combination...");
                
                return new Promise((resolve, reject) => {
                    try {
                        const img1 = new Image();
                        const img2 = new Image();
                        
                        let img1Loaded = false;
                        let img2Loaded = false;
                        
                        const checkBothLoaded = () => {
                            if (img1Loaded && img2Loaded) {
                                try {
                                    debugLog(`Both images loaded successfully. Dimensions: ${img1.width}x${img1.height} and ${img2.width}x${img2.height}`);
                                    
                                    const individualWidth = 2160;
                                    const individualHeight = 1920;
                                    
                                    const combinedWidth = 2160;
                                    const combinedHeight = 3840;
                                    
                                    const canvas = document.createElement('canvas');
                                    canvas.width = combinedWidth;
                                    canvas.height = combinedHeight;
                                    const ctx = canvas.getContext('2d');
                                    
                                    // Fill with black background
                                    ctx.fillStyle = "#000000";
                                    ctx.fillRect(0, 0, combinedWidth, combinedHeight);
                                    
                                    // Draw first image
                                    ctx.drawImage(
                                        img1, 
                                        0, 0, img1.width, img1.height,
                                        0, 0, individualWidth, individualHeight
                                    );
                                    
                                    // Draw second image
                                    ctx.drawImage(
                                        img2, 
                                        0, 0, img2.width, img2.height,
                                        0, individualHeight, individualWidth, individualHeight
                                    );
                                    
                                    // Add watermark
                                    ctx.font = 'bold 48px Arial';
                                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                                    ctx.textAlign = 'right';
                                    ctx.textBaseline = 'bottom';
                                    ctx.fillText('PixCrab', combinedWidth - 40, combinedHeight - 40);
                                    
                                    debugLog("Canvas rendering complete, converting to blob...");
                                    
                                    // Get the data URL directly (avoid blob conversion issues)
                                    const combinedUrl = canvas.toDataURL('image/jpeg', 0.95);
                                    const sizeEstimate = Math.round(combinedUrl.length / 1350); // Rough estimation
                                    imageSizeSpan.textContent = sizeEstimate;
                                    debugLog(`Combined image created successfully. Approx size: ${sizeEstimate} KB`);
                                    
                                    // Show success message
                                    showToast('Photos combined successfully!');
                                    
                                    resolve(combinedUrl);
                                } catch (error) {
                                    debugLog(`Error in canvas operations: ${error.message}`);
                                    reject(error);
                                }
                            }
                        };
                        
                        // Image 1 load handlers
                        img1.onload = () => {
                            img1Loaded = true;
                            debugLog("First image loaded");
                            checkBothLoaded();
                        };
                        
                        img1.onerror = (error) => {
                            debugLog(`Error loading first image: ${error}`);
                            reject(new Error("Failed to load first image"));
                        };
                        
                        // Image 2 load handlers
                        img2.onload = () => {
                            img2Loaded = true;
                            debugLog("Second image loaded");
                            checkBothLoaded();
                        };
                        
                        img2.onerror = (error) => {
                            debugLog(`Error loading second image: ${error}`);
                            reject(new Error("Failed to load second image"));
                        };
                        
                        // Set a timeout
                        setTimeout(() => {
                            if (!img1Loaded || !img2Loaded) {
                                debugLog(`Image loading timed out. img1: ${img1Loaded}, img2: ${img2Loaded}`);
                                reject(new Error("Image loading timed out"));
                            }
                        }, 15000);
                        
                        // Set cross-origin to anonymous
                        img1.crossOrigin = "anonymous";
                        img2.crossOrigin = "anonymous";
                        
                        // Start loading the images
                        img1.src = photo1;
                        img2.src = photo2;
                        
                        debugLog("Image loading started");
                    } catch (error) {
                        debugLog(`General error in photo combination: ${error.message}`);
                        reject(error);
                    }
                });
            }

            // Show a preview of the combined image with animation
            function showCombinedImagePreview(imageUrl) {
                debugLog("Showing combined image preview");
                
                // Create or get preview container
                let previewContainer = document.getElementById('combinedPreview');
                if (!previewContainer) {
                    previewContainer = document.createElement('div');
                    previewContainer.id = 'combinedPreview';
                    previewContainer.style.position = 'fixed';
                    previewContainer.style.top = '50%';
                    previewContainer.style.left = '50%';
                    previewContainer.style.transform = 'translate(-50%, -50%) scale(0.8)';
                    previewContainer.style.backgroundColor = 'rgba(0,0,0,0.9)';
                    previewContainer.style.borderRadius = '12px';
                    previewContainer.style.padding = '12px';
                    previewContainer.style.boxShadow = '0 8px 32px rgba(0,0,0,0.5)';
                    previewContainer.style.zIndex = '1000';
                    previewContainer.style.opacity = '0';
                    previewContainer.style.transition = 'all 0.3s ease';
                    
                    // Add close button
                    const closeBtn = document.createElement('button');
                    closeBtn.textContent = '×';
                    closeBtn.style.position = 'absolute';
                    closeBtn.style.top = '8px';
                    closeBtn.style.right = '8px';
                    closeBtn.style.backgroundColor = 'rgba(255,255,255,0.2)';
                    closeBtn.style.color = 'white';
                    closeBtn.style.border = 'none';
                    closeBtn.style.borderRadius = '50%';
                    closeBtn.style.width = '30px';
                    closeBtn.style.height = '30px';
                    closeBtn.style.fontSize = '20px';
                    closeBtn.style.cursor = 'pointer';
                    closeBtn.onclick = () => {
                        previewContainer.style.opacity = '0';
                        setTimeout(() => previewContainer.style.display = 'none', 300);
                    };
                    
                    previewContainer.appendChild(closeBtn);
                    document.body.appendChild(previewContainer);
                }
                
                // Create or update preview image
                let previewImg = previewContainer.querySelector('img');
                if (!previewImg) {
                    previewImg = document.createElement('img');
                    previewImg.style.maxHeight = '70vh';
                    previewImg.style.maxWidth = '90vw';
                    previewImg.style.display = 'block';
                    previewImg.style.margin = '0 auto';
                    previewImg.style.borderRadius = '8px';
                    previewContainer.appendChild(previewImg);
                }
                
                // Add caption
                let caption = previewContainer.querySelector('p');
                if (!caption) {
                    caption = document.createElement('p');
                    caption.style.color = 'white';
                    caption.style.textAlign = 'center';
                    caption.style.marginTop = '8px';
                    previewContainer.appendChild(caption);
                }
                caption.textContent = 'Combined photo created! Swipe up to view in gallery.';
                
                // Set image and show preview
                previewImg.src = imageUrl;
                previewContainer.style.display = 'block';
                
                // Animate in
                setTimeout(() => {
                    previewContainer.style.opacity = '1';
                    previewContainer.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 10);
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    previewContainer.style.opacity = '0';
                    setTimeout(() => previewContainer.style.display = 'none', 300);
                }, 5000);
            }
            
            // Share photo using Web Share API if available, fallback to copying link
            function sharePhoto(photoUrl) {
                debugLog("Attempting to share photo...");
                
                if (navigator.share) {
                    // Convert data URL to blob for sharing
                    fetch(photoUrl)
                        .then(res => res.blob())
                        .then(blob => {
                            const file = new File([blob], 'pixcrab_photo.jpg', { type: 'image/jpeg' });
                            navigator.share({
                                title: 'Check out our PixCrab photo!',
                                text: 'We captured this moment together with PixCrab',
                                files: [file]
                            }).then(() => {
                                debugLog("Share successful");
                            }).catch(err => {
                                debugLog(`Share failed: ${err.message}`);
                                fallbackShare(photoUrl);
                            });
                        })
                        .catch(err => {
                            debugLog(`Error converting photo for sharing: ${err.message}`);
                            fallbackShare(photoUrl);
                        });
                } else {
                    fallbackShare(photoUrl);
                }
            }
            
            // Fallback share method when Web Share API isn't available
            function fallbackShare(photoUrl) {
                debugLog("Using fallback share method");
                
                // Copy the photo URL to clipboard (data URL might be too large)
                try {
                    navigator.clipboard.writeText("Check out our PixCrab photo! Download it here: " + photoUrl)
                        .then(() => {
                            showToast('Photo link copied to clipboard!');
                            debugLog("Photo URL copied to clipboard");
                        })
                        .catch(err => {
                            debugLog(`Failed to copy photo URL: ${err.message}`);
                            showToast('Could not share photo. Try downloading it first.');
                        });
                } catch (err) {
                    debugLog(`Clipboard API not available: ${err.message}`);
                    showToast('Sharing not supported. Try downloading the photo first.');
                }
            }
            
            // Add photo slide to the container
            function addPhotoSlide(photoUrl) {
                debugLog("Adding photo slide...");
                
                const photoSlide = document.createElement('div');
                photoSlide.className = 'photo-slide';
                
                const photoWrapper = document.createElement('div');
                photoWrapper.className = 'photo-wrapper';
                
                const img = document.createElement('img');
                img.src = photoUrl;
                img.alt = 'Combined photo';
                
                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'photo-actions-container';
                
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'photo-action-btn';
                downloadBtn.innerHTML = 
                    `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>`;
                
                const shareBtn = document.createElement('button');
                shareBtn.className = 'photo-action-btn';
                shareBtn.innerHTML = 
                    `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="18" cy="5" r="3"></circle>
                        <circle cx="6" cy="12" r="3"></circle>
                        <circle cx="18" cy="19" r="3"></circle>
                        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                    </svg>`;
                
                downloadBtn.addEventListener('click', () => downloadPhoto(photoUrl));
                shareBtn.addEventListener('click', () => sharePhoto(photoUrl));
                
                actionsContainer.appendChild(downloadBtn);
                actionsContainer.appendChild(shareBtn);
                photoWrapper.appendChild(img);
                photoWrapper.appendChild(actionsContainer);
                photoSlide.appendChild(photoWrapper);
                slideContainer.appendChild(photoSlide);
                
                // Scroll to the new photo slide
                setTimeout(() => {
                    photoSlide.scrollIntoView({ behavior: 'smooth' });
                }, 300);
                
                debugLog("Photo slide added");
            }
            
            // Download photo
            function downloadPhoto(photoUrl) {
                if (!photoUrl) return;
                
                debugLog("Downloading photo...");
                const link = document.createElement('a');
                link.href = photoUrl;
                link.download = `pixcrab_${currentSessionId}_${new Date().toISOString().slice(0,10)}.jpg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                debugLog("Download initiated");
            }
            
            // Join a session
            function joinSession(sessionId, isOwner = false) {
                debugLog(`Joining session ${sessionId} as ${isOwner ? 'owner' : 'participant'}`);
               // Antes de ocultar UI y conectar...
currentSessionId = sessionId;
isSessionOwner  = isOwner;
userId          = currentUser.uid;    // ← Ahora usa el UID de Firebase Auth
lastCaptureTime = 0;

                
                displaySessionId.textContent = sessionId;
                
                initCamera();
                
                sessionSetup.classList.add('hidden');
                cameraSection.classList.remove('hidden');
                
                captureBtn.disabled = false;
                statusText.textContent = 'Connecting...';
                connectionStatus.className = 'w-3 h-3 rounded-full status-connecting mr-2';
                
                const sessionRef = database.ref(`sessions/${sessionId}`);
                
                participantsRef = database.ref(`sessions/${sessionId}/participants`);
                participantRef = participantsRef.child(userId);
                
                participantRef.set({
                    active: true,
                    lastActive: firebase.database.ServerValue.TIMESTAMP
                });
                
                participantRef.onDisconnect().remove();
                
                // Watch for participants to hide QR when someone joins
     participantsRef.on('value', (snapshot) => {
    if (snapshot.exists()) {
        const participants = snapshot.val();
        const participantCount = Object.keys(participants).length;

        // ✅ Incluye al creador de la sesión como peer
        peerCount.textContent = `${participantCount} ${participantCount === 1 ? 'peer' : 'peers'} connected`;
        debugLog(`Participant count updated: ${participantCount} total peers`);

        // 🔁 Cambio dinámico de color
        if (participantCount > 1) {
            peerCount.style.color = '#CCF381'; // Color fuerte cuando hay más de 1
            qrContainer.classList.add('hidden');
            debugLog("Second participant joined, hiding QR overlay");
        } else {
            peerCount.style.color = '#999999'; // Color apagado cuando solo hay uno
        }
    } else {
        peerCount.textContent = '0 peers connected';
        peerCount.style.color = '#999999';
        debugLog("No participants in session");
    }
});

                
                sessionRef.child('capture').on('value', (snapshot) => {
                    if (snapshot.exists()) {
                        const captureData = snapshot.val();
                        if (captureData.captureTime && captureData.captureTime !== lastCaptureTime) {
                            lastCaptureTime = captureData.captureTime;
                            debugLog(`Received capture command for time: ${new Date(captureData.captureTime).toISOString()}`);
                            startCountdown(captureData.captureTime);
                        }
                    }
                });
                
                // Watch for photo updates and combine when 2+ photos are available
                sessionRef.child('photos').on('value', (snapshot) => {
                    try {
                        if (snapshot.exists()) {
                            const photos = snapshot.val();
                            const photoKeys = Object.keys(photos);
                            
                            debugLog(`Photos update in session: ${photoKeys.length} photos available`);
                            
                            if (photoKeys.length >= 2) {
                                debugLog(`Photo details: ${JSON.stringify(photos)}`);
                                
                                // Get photo URLs - simplify to just an array of URLs
                                const photoUrls = [];
                                
                                for (const key in photos) {
                                    if (photos[key] && photos[key].photoData) {
                                        photoUrls.push(photos[key].photoData);
                                        debugLog(`Valid photo found for user ${key}`);
                                    } else {
                                        debugLog(`Warning: Malformed photo data for user ${key}`);
                                    }
                                }
                                
                                // Check if we have enough valid photo URLs
                                if (photoUrls.length >= 2) {
                                    debugLog(`Both photos received, combining... URLs count: ${photoUrls.length}`);
                                    
                                    // Simple direct approach - just use the first two photos
                                    combinePhotosSimple(photoUrls[0], photoUrls[1])
                                        .then(combinedUrl => {
                                            debugLog("Photos combined successfully, updating UI");
                                            
                                            // Return to camera view
                                            photoResult.style.display = 'none';
                                            cameraFeed.style.display = 'block';
                                            
                                            // Add the combined photo to the slideshow/gallery
                                            addPhotoSlide(combinedUrl);
                                            imageQualityInfo.classList.remove('hidden');
                                            
                                            debugLog("Combined photo displayed in new slide");
                                            showToast('Photos combined! Swipe up to view.');
                                            
                                            // Show the hint to swipe up
                                            hintText.style.opacity = '1';
                                            setTimeout(() => {
                                                hintText.style.opacity = '0';
                                            }, 3000);
                                            
                                            // Clear photos from session for next capture
                                            debugLog("Clearing photos from Firebase for next capture");
                                            sessionRef.child('photos').remove();
                                        })
                                        .catch(error => {
                                            debugLog(`Error combining photos: ${error.message}`);
                                            showToast('Error combining photos');
                                            
                                            // Return to camera view even if combination fails
                                            photoResult.style.display = 'none';
                                            cameraFeed.style.display = 'block';
                                        });
                                } else {
                                    debugLog(`Not enough valid photo URLs to combine: ${photoUrls.length}`);
                                }
                            } else {
                                debugLog(`Waiting for more photos. Current count: ${photoKeys.length}`);
                            }
                        } else {
                            debugLog("No photos in session");
                        }
                    } catch (error) {
                        debugLog(`Error processing photos: ${error.message}`);
                        
                        // Return to camera view if error occurs
                        photoResult.style.display = 'none';
                        cameraFeed.style.display = 'block';
                    }
                });
                
                sessionRef.on('value', (snapshot) => {
                    if (snapshot.exists()) {
                        statusText.textContent = 'Connected';
                        connectionStatus.className = 'w-3 h-3 rounded-full status-connected mr-2';
                        debugLog("Connected to Firebase session");
                    } else {
                        statusText.textContent = 'Disconnected';
                        connectionStatus.className = 'w-3 h-3 rounded-full status-disconnected mr-2';
                        debugLog("Disconnected from Firebase session");
                    }
                });
                
                sessionRef.on('value', (snapshot) => {
                    if (!snapshot.exists()) {
                        debugLog("Session ended by owner");
                        showToast('Session ended');
                        leaveSession();
                    }
                });
                loadGalleryPhotos();
            }
            
            // Leave current session
            function leaveSession() {
                debugLog("Leaving current session...");
                if (currentSessionId) {
                    if (participantRef) {
                        participantRef.remove();
                    }
                    
                    database.ref(`sessions/${currentSessionId}/photos/${userId}`).remove();
                    
                    if (participantsRef) {
                        participantsRef.off();
                    }
                    
                    database.ref(`sessions/${currentSessionId}`).off();
                    
                    if (isSessionOwner) {
                        debugLog("Removing session from Firebase (owner)");
                        database.ref(`sessions/${currentSessionId}`).remove();
                    }
                    
                    currentSessionId = null;
                    stopCamera();
                    
                    sessionSetup.classList.remove('hidden');
                    cameraSection.classList.add('hidden');
                    photoResult.style.display = 'none';
                    cameraFeed.style.display = 'block';
                    imageQualityInfo.classList.add('hidden');
                    cameraSwitchBtn.classList.add('hidden');
                    qrContainer.classList.add('hidden');
                    
                    // Remove all photo slides except the first one (camera view)
                    while (slideContainer.children.length > 1) {
                        slideContainer.removeChild(slideContainer.lastChild);
                    }
                    
                    if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownOverlay.classList.add('hidden');
                    }
                    
                    debugLog("Session left successfully");
                }
            }
            
            // Copy session ID to clipboard
            sessionIdBadge.addEventListener('click', () => {
                navigator.clipboard.writeText(currentSessionId).then(() => {
                    showToast('Session ID copied!');
                    debugLog("Session ID copied to clipboard");
                }).catch(err => {
                    debugLog(`Could not copy session ID: ${err.message}`);
                });
            });
            
            // Event listeners
            joinSessionBtn.addEventListener('click', () => {
                debugLog("Join session button clicked");
                const sessionId = sessionIdInput.value.trim();
                debugLog(`Session ID entered: ${sessionId}`);
                if (sessionId.length >= 4) {
                    debugLog(`Attempting to join session: ${sessionId}`);
                    joinSession(sessionId, false);
                } else {
                    debugLog("Invalid session ID entered");
                    showToast('Please enter a valid session ID');
                }
            });
            
            createSessionBtn.addEventListener('click', async () => {
                debugLog("Create session button clicked");
                
                try {
                    // Check if the user is authenticated
                    if (!currentUser) {
                        debugLog("No user logged in, attempting anonymous login");
                        try {
                            await auth.signInAnonymously();
                            debugLog("Anonymous login successful");
                        } catch (authError) {
                            debugLog(`Anonymous login failed: ${authError.message}`);
                            showToast('Failed to create session - authentication error');
                            return;
                        }
                    }
                    
                    // Add button press effect
                    createSessionBtn.classList.add('active');
                    setTimeout(() => {
                        createSessionBtn.classList.remove('active');
                    }, 100);
                    
                    const sessionId = await generateSafeSessionId();
                    debugLog(`Generated new session ID: ${sessionId}`);
                    
                    // Initialize the session with a participants node
                    await database.ref(`sessions/${sessionId}`).set({
                        created: Date.now(),
                        createdBy: currentUser.uid,
                        participants: {
                            [currentUser.uid]: {
                                active: true,
                                lastActive: firebase.database.ServerValue.TIMESTAMP
                            }
                        }
                    });
                    
                    debugLog("Session created in Firebase");
                    
                    // Generate QR code for the new session
                    generateQRCode(sessionId);
                    
                    // Update UI
                    sessionIdInput.value = sessionId;
                    showToast('New session created! Scan the QR code to share');
                    
                    // Join the session as owner
                    debugLog("Joining session as owner");
                    joinSession(sessionId, true);
                } catch (err) {
                    debugLog(`Session creation failed: ${err.message}`);
                    console.error(err);
                    showToast('Failed to create session');
                }
            });
            
            captureBtn.addEventListener('click', () => {
                const now = Date.now();
                if (now - lastCaptureTime < 5000) {
                    debugLog("Capture too soon after last capture");
                    showToast('Please wait before capturing again');
                    return;
                }
                
                const captureTime = Date.now() + 4000;
                lastCaptureTime = captureTime;
                
                debugLog(`Initiating capture sequence for ${new Date(captureTime).toISOString()}`);
                
                database.ref(`sessions/${currentSessionId}/capture`).set({
                    captureTime: captureTime
                }).then(() => {
                    debugLog("Capture command sent to Firebase");
                }).catch(err => {
                    debugLog(`Failed to send capture command: ${err.message}`);
                });
                
                startCountdown(captureTime);
            });
            
            newSessionBtn.addEventListener('click', leaveSession);
            
            cameraSwitchBtn.addEventListener('click', switchCamera);
            
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    debugLog("Page hidden, pausing camera");
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                    }
                } else {
                    if (currentSessionId && !stream) {
                        debugLog("Page visible again, resuming camera");
                        initCamera();
                    }
                }
            });
            
            // Touch events for swipe navigation
            document.addEventListener('touchstart', (e) => {
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });
            
            document.addEventListener('touchend', (e) => {
                touchEndY = e.changedTouches[0].screenY;
                const threshold = 50;
                
                // Only allow swipe navigation if we're in the camera section
                if (!cameraSection.classList.contains('hidden')) {
                    if (touchStartY - touchEndY > threshold) {
                        // Swipe up - scroll to next photo slide if available
                        const currentSlide = document.elementFromPoint(
                            window.innerWidth / 2, 
                            window.innerHeight / 2
                        ).closest('.slide, .photo-slide');
                        
                        if (currentSlide && currentSlide.nextElementSibling) {
                            currentSlide.nextElementSibling.scrollIntoView({ behavior: 'smooth' });
                        }
                    } else if (touchEndY - touchStartY > threshold) {
                        // Swipe down - scroll to previous slide (usually back to camera)
                        const currentSlide = document.elementFromPoint(
                            window.innerWidth / 2, 
                            window.innerHeight / 2
                        ).closest('.slide, .photo-slide');
                        
                        if (currentSlide && currentSlide.previousElementSibling) {
                            currentSlide.previousElementSibling.scrollIntoView({ behavior: 'smooth' });
                        }
                    }
                }
            }, { passive: true });
            
            // Check for session ID in URL on page load
            window.addEventListener('load', () => {
                const params = new URLSearchParams(window.location.search);
                const qrSession = params.get('sessionId');
                
                if (qrSession) {
                    debugLog(`Found session ID in URL: ${qrSession}`);
                    sessionIdInput.value = qrSession;
                    joinSessionBtn.click();
                }
                
                if (!localStorage.getItem('pixcrab_visited')) {
                    showToast('Share the session ID or QR code with a friend to sync photos!');
                    localStorage.setItem('pixcrab_visited', 'true');
                    debugLog("First-time user welcome message shown");
                }
            });
auth.onAuthStateChanged((user) => {
    try {
        debugLog(`Auth state changed: user ${user ? 'signed in' : 'signed out'}`);
        
        if (user) {
            currentUser = user;
            
            if (user.isAnonymous) {
                debugLog('Signed in as guest');
                showToast('Guest session active');
                showCenteredToast('Logged in successfully!');
            } else {
                debugLog(`User signed in: ${user.email}`);
                showToast(`Signed in as ${user.displayName || user.email}`);
                showCenteredToast('Logged in successfully!');
            }
            
            document.getElementById('authSection').classList.add('hidden');
            sessionSetup.classList.remove('hidden');

            // Auto-join session for guests with sessionId in URL
            const params = new URLSearchParams(window.location.search);
            const qrSession = params.get('sessionId');
            if (qrSession) {
                debugLog(`Session ID found in URL: ${qrSession}`);
                sessionIdInput.value = qrSession;
                if (joinSessionBtn && !joinSessionBtn.disabled) {
                    debugLog('Auto-joining session from URL');
                    joinSession(qrSession, false);
                }
            }
        } else {
            // User is signed out
            debugLog("User is signed out");
            currentUser = null;
            
            // Clean up any active sessions
            if (currentSessionId) {
                leaveSession();
            }
            
            // Reset UI to auth screen
            document.getElementById('authSection').classList.remove('hidden');
            sessionSetup.classList.add('hidden');
            cameraSection.classList.add('hidden');
            
            // Stop camera
            stopCamera();
            
            // Reset UI elements
            photoResult.style.display = 'none';
            cameraFeed.style.display = 'block';
            imageQualityInfo.classList.add('hidden');
            cameraSwitchBtn.classList.add('hidden');
            qrContainer.classList.add('hidden');
            
            // Clear any slideshow elements
            while (slideContainer.children.length > 1) {
                slideContainer.removeChild(slideContainer.lastChild);
            }
            
            // Clear gallery
            gallerySection.innerHTML = '';
            
            debugLog("UI reset after sign out");
        }
    } catch (error) {
        debugLog(`Error in auth state handler: ${error.message}`);
        console.error('Auth state handler error:', error);
    }
});

// Improved logout function
function logout() {
    debugLog("Logout initiated");
    
    // Clean up before logout
    if (currentSessionId) {
        debugLog("Cleaning up active session before logout");
        leaveSession();
    }
    
    // Actually sign out
    auth.signOut().then(() => {
        debugLog("Sign out successful");
        showToast('Signed out');
    }).catch(error => {
        debugLog(`Sign out error: ${error.message}`);
        console.error('Sign out error:', error);
        showToast('Failed to sign out');
    });
}

// Add proper error handling to Google sign-in
document.getElementById('googleSignIn').addEventListener('click', () => {
    debugLog("Google sign-in clicked");
    
    try {
        const provider = new firebase.auth.GoogleAuthProvider();
        showToast('Signing in with Google...');
        
        auth.signInWithPopup(provider)
            .then(() => {
                debugLog("Google sign-in successful");
            })
            .catch(error => {
                debugLog(`Google sign-in error: ${error.message}`);
                console.error("Google sign-in error:", error);
                showToast('Failed to sign in with Google');
            });
    } catch (error) {
        debugLog(`Error initializing Google sign-in: ${error.message}`);
        console.error("Error initializing Google sign-in:", error);
        showToast('Failed to start Google sign-in');
    }
});

// Add proper error handling to Apple sign-in
document.getElementById('appleSignIn').addEventListener('click', () => {
    debugLog("Apple sign-in clicked");
    
    try {
        const provider = new firebase.auth.OAuthProvider('apple.com');
        showToast('Signing in with Apple...');
        
        auth.signInWithPopup(provider)
            .then(() => {
                debugLog("Apple sign-in successful");
            })
            .catch(error => {
                debugLog(`Apple sign-in error: ${error.message}`);
                console.error("Apple sign-in error:", error);
                showToast('Failed to sign in with Apple');
            });
    } catch (error) {
        debugLog(`Error initializing Apple sign-in: ${error.message}`);
        console.error("Error initializing Apple sign-in:", error);
        showToast('Failed to start Apple sign-in');
    }
});

// Add proper error handling to guest sign-in
document.getElementById('guestSignIn').addEventListener('click', () => {
    debugLog("Guest sign-in clicked");
    
    try {
        showToast('Signing in as guest...');
        
        auth.signInAnonymously()
            .then(() => {
                debugLog("Anonymous sign-in successful");
            })
            .catch(error => {
                debugLog(`Anonymous sign-in error: ${error.message}`);
                console.error("Anonymous sign-in error:", error);
                showToast('Failed to continue as guest');
            });
    } catch (error) {
        debugLog(`Error initializing anonymous sign-in: ${error.message}`);
        console.error("Error initializing anonymous sign-in:", error);
        showToast('Failed to start guest sign-in');
    }
});

// Add this function to show a gallery indicator
function showGalleryIndicator() {
    debugLog("Showing gallery indicator");
    
    // Create or get the indicator
    let indicator = document.getElementById('galleryIndicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'galleryIndicator';
        indicator.style.position = 'fixed';
        indicator.style.bottom = '80px';
        indicator.style.left = '50%';
        indicator.style.transform = 'translateX(-50%)';
        indicator.style.backgroundColor = 'rgba(204, 243, 129, 0.8)';
        indicator.style.color = '#4831D4';
        indicator.style.padding = '8px 16px';
        indicator.style.borderRadius = '20px';
        indicator.style.fontWeight = 'bold';
        indicator.style.zIndex = '99';
        indicator.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        indicator.style.animation = 'pulse 2s infinite';
        
        // Add arrow icon
        const arrowIcon = document.createElement('span');
        arrowIcon.innerHTML = '⬆️';
        arrowIcon.style.marginRight = '6px';
        
        // Add text
        const text = document.createElement('span');
        text.textContent = 'View Gallery';
        
        indicator.appendChild(arrowIcon);
        indicator.appendChild(text);
        
        // Add click event to scroll to gallery
        indicator.addEventListener('click', () => {
            if (slideContainer.children.length > 1) {
                slideContainer.children[1].scrollIntoView({ behavior: 'smooth' });
            }
        });
        
        // Add the indicator to the page
        document.body.appendChild(indicator);
        
        // Add pulse animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0% { transform: translateX(-50%) scale(1); }
                50% { transform: translateX(-50%) scale(1.1); }
                100% { transform: translateX(-50%) scale(1); }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Show the indicator
    indicator.style.display = 'block';
    
    // Auto-hide after 8 seconds
    setTimeout(() => {
        indicator.style.display = 'none';
    }, 8000);
}

// Modify gallerySection styling to make it more prominent
document.addEventListener('DOMContentLoaded', () => {
    const gallerySection = document.getElementById('gallerySection');
    if (gallerySection) {
        // Make gallery more visible
        gallerySection.style.background = 'rgba(72, 49, 212, 0.8)';
        gallerySection.style.padding = '12px';
        gallerySection.style.borderRadius = '16px';
        gallerySection.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
        gallerySection.style.backdropFilter = 'blur(5px)';
        gallerySection.style.margin = '0 8px';
        
        // Add gallery heading
        const galleryHeading = document.createElement('div');
        galleryHeading.textContent = 'Photo Gallery';
        galleryHeading.style.color = '#CCF381';
        galleryHeading.style.fontWeight = 'bold';
        galleryHeading.style.fontSize = '14px';
        galleryHeading.style.marginBottom = '8px';
        galleryHeading.style.textAlign = 'center';
        
        // Add the heading to the gallery
        gallerySection.insertBefore(galleryHeading, gallerySection.firstChild);
    }
});

// Update the uploadCombinedPhoto function to show the gallery indicator
async function uploadCombinedPhoto(combinedDataUrl, sessionId, userIds, originalPhotoIds) {
    // Existing code...
    
    // Rest of the function remains unchanged
    if (!combinedDataUrl) {
      debugLog("Error: Missing combined photo data URL");
      throw new Error("Missing combined photo data URL");
    }
    
    if (!sessionId) {
      debugLog("Error: Missing session ID for combined photo");
      throw new Error("Missing session ID");
    }
    
    if (!userIds || !userIds.length) {
      debugLog("Error: Missing user IDs for combined photo");
      throw new Error("Missing user IDs");
    }
    
    debugLog(`Uploading combined photo for users: ${userIds.join(', ')} in session ${sessionId}`);
    
    try {
        const timestamp = Date.now();
        const combinedPhotoId = `${timestamp}_${originalPhotoIds.join('_')}`;
        debugLog(`Combined photo ID: ${combinedPhotoId}`);

        // Convert data URL to blob
        debugLog("Converting data URL to blob...");
        const blob = await fetch(combinedDataUrl).then(res => res.blob());
        const fileSize = blob.size;
        debugLog(`Combined photo size: ${Math.round(fileSize/1024)} KB`);

        // Generate thumbnail (200px wide)
        debugLog("Generating thumbnail...");
        const thumbDataUrl = await new Promise((resolve, reject) => {
          try {
            const img = new Image();
            
            img.onload = function() {
              try {
                const scale = 200 / img.width;
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = Math.round(img.height * scale);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                resolve(canvas.toDataURL('image/jpeg', 0.7));
              } catch (err) {
                debugLog(`Error creating thumbnail: ${err.message}`);
                reject(err);
              }
            };
            
            img.onerror = function(err) {
              debugLog(`Error loading image for thumbnail: ${err}`);
              reject(new Error("Failed to load image for thumbnail"));
            };
            
            img.src = combinedDataUrl;
          } catch (err) {
            debugLog(`Error in thumbnail generation: ${err.message}`);
            reject(err);
          }
        });
        
        debugLog("Thumbnail generated successfully");
        const thumbBlob = await fetch(thumbDataUrl).then(res => res.blob());
        debugLog(`Thumbnail size: ${Math.round(thumbBlob.size/1024)} KB`);

        // For each user, upload and store metadata
        debugLog(`Processing for ${userIds.length} users...`);
        let uploadCount = 0;
        
        for (const uid of userIds) {
          // Skip if uid is undefined or null
          if (!uid) {
            debugLog(`Skipping undefined/null user ID`);
            continue;
          }
          
          try {
            debugLog(`Processing combined photo for user: ${uid}`);
            
            // Create storage references
            const storageRef = storage.ref(`users/${uid}/combined/${combinedPhotoId}.jpg`);
            const thumbRef = storage.ref(`users/${uid}/combined/${combinedPhotoId}_thumb.jpg`);
            
            // Upload full image
            debugLog(`Uploading full image for user ${uid}...`);
            await storageRef.put(blob);
            debugLog(`Full image uploaded for user ${uid}`);
            
            // Upload thumbnail
            debugLog(`Uploading thumbnail for user ${uid}...`);
            await thumbRef.put(thumbBlob);
            debugLog(`Thumbnail uploaded for user ${uid}`);
            
            // Get download URLs
            debugLog(`Getting download URLs for user ${uid}...`);
            const url = await storageRef.getDownloadURL();
            const thumbnailUrl = await thumbRef.getDownloadURL();
            debugLog(`Download URLs retrieved for user ${uid}`);

            // Build summary metadata
            const summary = {
              photoId: combinedPhotoId,
              url,
              thumbnailUrl,
              sessionId,
              timestamp,
              combined: true,
              otherUserId: userIds.find(id => id !== uid),
              originalPhotoIds,
              size: fileSize,
            };
            
            // Store summary under user's photos
            debugLog(`Saving metadata to user/${uid}/photos/${combinedPhotoId}`);
            await database.ref(`users/${uid}/photos/${combinedPhotoId}`).set(summary);
            
            // Store in session history
            debugLog(`Adding to user/${uid}/sessions/${sessionId}/photoIds/${combinedPhotoId}`);
            await database.ref(`users/${uid}/sessions/${sessionId}/photoIds/${combinedPhotoId}`).set(true);
            
            debugLog(`Combined photo metadata saved for user: ${uid}`);
            uploadCount++;
          } catch (userError) {
            debugLog(`Error processing for user ${uid}: ${userError.message}`);
            console.error(`Error processing for user ${uid}:`, userError);
            // Continue with other users even if one fails
          }
        }
        
        debugLog(`Combined photo upload complete for ${uploadCount}/${userIds.length} users`);
        
        // Show gallery indicator after successful upload
        showGalleryIndicator();
        
        return uploadCount > 0; // Success if at least one user was processed
    } catch (error) {
        debugLog(`Error uploading combined photo: ${error.message}`);
        console.error("Combined photo upload error:", error);
        throw error; // Re-throw to allow caller to handle it
    }
}

// Add photo to gallery as thumbnail
function addGalleryPhoto(photo) {
    debugLog('Adding photo to gallery...');
    
    // Create wrapper and container for the thumbnail
    const wrapper = document.createElement('div');
    wrapper.className = 'gallery-photo-wrapper';
    wrapper.style.position = 'relative';
    wrapper.style.display = 'inline-block';
    wrapper.style.width = '80px';
    wrapper.style.height = '80px';
    wrapper.style.overflow = 'hidden';
    wrapper.style.borderRadius = '10px';
    wrapper.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
    wrapper.style.background = '#222';
    wrapper.style.marginRight = '8px';
    
    // Create the image element
    const img = document.createElement('img');
    img.src = photo.thumbnailUrl || photo.url; // Use thumbnail if available, otherwise full image
    img.alt = 'Gallery photo';
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'cover';
    img.style.borderRadius = '10px';
    img.style.cursor = 'pointer';
    
    // Loading indicator 
    img.style.opacity = '0.5';
    img.onload = () => {
        img.style.opacity = '1';
        img.style.transition = 'opacity 0.3s ease';
    };
    
    // On click, open modal with full image
    img.onclick = () => openPhotoModal(photo.url);
    
    // Create download button
    const dlBtn = document.createElement('button');
    dlBtn.innerHTML = '⬇️';
    dlBtn.title = 'Download';
    dlBtn.style.position = 'absolute';
    dlBtn.style.bottom = '4px';
    dlBtn.style.right = '4px';
    dlBtn.style.background = 'rgba(72,49,212,0.7)';
    dlBtn.style.color = '#CCF381';
    dlBtn.style.border = 'none';
    dlBtn.style.borderRadius = '50%';
    dlBtn.style.width = '24px';
    dlBtn.style.height = '24px';
    dlBtn.style.fontSize = '1em';
    dlBtn.style.cursor = 'pointer';
    
    // Stop propagation to prevent opening modal when clicking download
    dlBtn.onclick = (e) => { 
        e.stopPropagation(); 
        downloadPhoto(photo.url);
    };
    
    // Assemble the components
    wrapper.appendChild(img);
    wrapper.appendChild(dlBtn);
    
    // Prepend to gallery (newest first)
    gallerySection.prepend(wrapper);
    
    // Make sure gallery is visible
    gallerySection.classList.remove('hidden');
    
    debugLog(`Photo added to gallery: ${photo.photoId || 'unknown ID'}`);
}

// Modal logic
const photoModal = document.getElementById('photoModal');
const modalFullImg = document.getElementById('modalFullImg');
const modalDownloadBtn = document.getElementById('modalDownloadBtn');
const modalShareBtn = document.getElementById('modalShareBtn');
const modalCloseBtn = document.getElementById('modalCloseBtn');
let currentModalUrl = '';
function openPhotoModal(url) {
    currentModalUrl = url;
    modalFullImg.src = url;
    photoModal.classList.remove('hidden');
}
modalCloseBtn.onclick = () => {
    photoModal.classList.add('hidden');
    modalFullImg.src = '';
    currentModalUrl = '';
};
modalDownloadBtn.onclick = () => downloadPhoto(currentModalUrl);
modalShareBtn.onclick = () => sharePhoto(currentModalUrl);
photoModal.onclick = (e) => {
    if (e.target === photoModal) modalCloseBtn.onclick();
};

// Load gallery photos for user (thumbnails)
async function loadGalleryPhotos() {
    try {
        if (!currentUser) {
            debugLog("Cannot load gallery - user not signed in");
            return;
        }
        
        debugLog("Loading gallery photos for user");
        gallerySection.innerHTML = ''; // Clear existing content
        
        const userId = currentUser.uid;
        const photosRef = database.ref(`users/${userId}/photos`);
        
        const snapshot = await photosRef.once('value');
        
        if (snapshot.exists()) {
            const photos = snapshot.val();
            const photoEntries = Object.entries(photos)
                .filter(([_, photo]) => photo.combined && (photo.thumbnailUrl || photo.url))
                .sort((a, b) => b[1].timestamp - a[1].timestamp); // Sort newest first
            
            if (photoEntries.length > 0) {
                debugLog(`Found ${photoEntries.length} gallery photos`);
                photoEntries.forEach(([_, photo]) => {
                    addGalleryPhoto(photo);
                });
                // Make gallery visible
                gallerySection.classList.remove('hidden');
            } else {
                debugLog("No combined photos found in gallery");
                gallerySection.innerHTML = '<div class="text-gray-400 text-center p-4">No photos yet</div>';
            }
        } else {
            debugLog("No photos found for user");
            gallerySection.innerHTML = '<div class="text-gray-400 text-center p-4">No photos yet</div>';
        }
    } catch (error) {
        debugLog(`Error loading gallery photos: ${error.message}`);
        gallerySection.innerHTML = '<div class="text-red-400 text-center p-4">Error loading photos</div>';
    }
}

// Centered toast for login success
function showCenteredToast(message) {
    let centeredToast = document.getElementById('centeredToast');
    if (!centeredToast) {
        centeredToast = document.createElement('div');
        centeredToast.id = 'centeredToast';
        centeredToast.style.position = 'fixed';
        centeredToast.style.top = '50%';
        centeredToast.style.left = '50%';
        centeredToast.style.transform = 'translate(-50%, -50%)';
        centeredToast.style.background = '#CCF381';
        centeredToast.style.color = '#4831D4';
        centeredToast.style.fontWeight = 'bold';
        centeredToast.style.fontSize = '1.3rem';
        centeredToast.style.padding = '18px 36px';
        centeredToast.style.borderRadius = '18px';
        centeredToast.style.boxShadow = '0 8px 32px rgba(72,49,212,0.18)';
        centeredToast.style.zIndex = '99999';
        centeredToast.style.textAlign = 'center';
        centeredToast.style.opacity = '0';
        centeredToast.style.transition = 'opacity 0.3s';
        document.body.appendChild(centeredToast);
    }
    centeredToast.textContent = message;
    centeredToast.style.opacity = '1';
    centeredToast.classList.remove('hidden');
    setTimeout(() => {
        centeredToast.style.opacity = '0';
        setTimeout(() => centeredToast.classList.add('hidden'), 400);
    }, 2000);
}

// Add signout button event listener
if (signOutBtn) {
    signOutBtn.addEventListener('click', logout);
}

        });
    </script>
<style>
    /* Base styles */
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #1a1a1a;
        color: #ffffff;
        height: 100vh;
        overflow: hidden;
    }
    
    /* Main container */
    .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        max-width: 100%;
        margin: 0 auto;
        position: relative;
    }
    
    /* Authentication section */
    #authSection {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        background-color: #4831D4;
        color: #CCF381;
        text-align: center;
        padding: 20px;
        z-index: 50;
    }
    
    .auth-logo {
        font-size: 2.5rem;
        font-weight: bold;
        margin-bottom: 2rem;
    }
    
    .auth-message {
        font-size: 1.2rem;
        margin-bottom: 2rem;
        max-width: 300px;
    }
    
    .auth-buttons {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: 100%;
        max-width: 300px;
    }
    
    .auth-btn {
        padding: 1rem;
        border-radius: 0.5rem;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s;
    }
    
    .auth-btn:active {
        transform: scale(0.98);
    }
    
    #googleSignIn {
        background-color: #ffffff;
        color: #4285F4;
    }
    
    #appleSignIn {
        background-color: #000000;
        color: #ffffff;
    }
    
    #guestSignIn {
        background-color: #CCF381;
        color: #4831D4;
    }
    
    /* Session setup section */
    #sessionSetup {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        background-color: #4831D4;
        color: #CCF381;
        text-align: center;
        padding: 20px;
        z-index: 40;
    }
    
    .session-logo {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 1.5rem;
    }
    
    .session-message {
        font-size: 1rem;
        margin-bottom: 1.5rem;
        max-width: 300px;
    }
    
    .session-input {
        display: flex;
        width: 100%;
        max-width: 300px;
        margin-bottom: 1rem;
    }
    
    #sessionId {
        flex-grow: 1;
        padding: 0.75rem;
        border-radius: 0.5rem 0 0 0.5rem;
        border: none;
        background-color: #ffffff;
        color: #333333;
        font-size: 1rem;
        text-transform: uppercase;
    }
    
    #joinSession {
        padding: 0.75rem 1rem;
        border-radius: 0 0.5rem 0.5rem 0;
        border: none;
        background-color: #CCF381;
        color: #4831D4;
        font-weight: bold;
        cursor: pointer;
    }
    
    #createSession {
        width: 100%;
        max-width: 300px;
        padding: 0.75rem;
        border-radius: 0.5rem;
        border: none;
        background-color: #CCF381;
        color: #4831D4;
        font-weight: bold;
        font-size: 1rem;
        cursor: pointer;
        margin-bottom: 1rem;
        transition: transform 0.2s;
    }
    
    #createSession:active {
        transform: scale(0.98);
    }
    
    #signOutBtn {
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        border: 1px solid #CCF381;
        background-color: transparent;
        color: #CCF381;
        font-weight: bold;
        cursor: pointer;
        margin-top: 2rem;
    }
    
    /* Camera section */
    #cameraSection {
        position: relative;
        flex: 1;
        display: flex;
        flex-direction: column;
        background-color: #000000;
        overflow: hidden;
    }
    
    .camera-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem 1rem;
        background-color: rgba(0,0,0,0.7);
        z-index: 10;
    }
    
    .session-badge {
        display: flex;
        align-items: center;
        background-color: rgba(72, 49, 212, 0.8);
        color: #CCF381;
        padding: 0.25rem 0.5rem;
        border-radius: 1rem;
        font-size: 0.8rem;
        cursor: pointer;
    }
    
    .camera-status {
        display: flex;
        align-items: center;
        font-size: 0.8rem;
        color: #cccccc;
    }
    
    .status-connected {
        background-color: #4CAF50;
    }
    
    .status-connecting {
        background-color: #FFC107;
    }
    
    .status-disconnected {
        background-color: #F44336;
    }
    
    .camera-feed-container {
        flex: 1;
        position: relative;
        overflow: hidden;
    }
    
    #cameraFeed {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    #photoResult {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: none;
    }
    
    .camera-controls {
        display: flex;
        justify-content: space-around;
        align-items: center;
        padding: 1rem;
        background-color: rgba(0,0,0,0.7);
        z-index: 10;
    }
    
    #captureBtn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: 3px solid #ffffff;
        background-color: #4831D4;
        cursor: pointer;
    }
    
    #newSessionBtn {
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        border: none;
        background-color: #333333;
        color: #ffffff;
        cursor: pointer;
    }
    
    /* Slideshow container */
    #slideContainer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow-y: auto;
        scroll-snap-type: y mandatory;
        z-index: 5;
    }
    
    .slide {
        scroll-snap-align: start;
        height: 100vh;
        width: 100%;
        display: flex;
        flex-direction: column;
    }
    
    .photo-slide {
        scroll-snap-align: start;
        height: 100vh;
        width: 100%;
        background-color: #000000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }
    
    .photo-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    
    .photo-wrapper img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
    }
    
    .photo-actions-container {
        position: absolute;
        bottom: 2rem;
        display: flex;
        gap: 1rem;
    }
    
    .photo-action-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: rgba(72, 49, 212, 0.8);
        color: #CCF381;
        border: none;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    
    .photo-action-btn svg {
        width: 24px;
        height: 24px;
    }
    
    /* Countdown overlay */
    #countdownOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 20;
    }
    
    #countdownText {
        font-size: 6rem;
        font-weight: bold;
        color: #ffffff;
    }
    
    #captureText {
        font-size: 3rem;
        font-weight: bold;
        color: #CCF381;
    }
    
    /* Toast notification */
    #toast {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0,0,0,0.8);
        color: #ffffff;
        padding: 0.75rem 1.5rem;
        border-radius: 2rem;
        z-index: 100;
        transition: opacity 0.3s;
    }
    
    /* QR code */
    #qrcode {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #ffffff;
        padding: 1rem;
        border-radius: 1rem;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
        z-index: 15;
    }
    
    #qrFallback {
        margin-top: 0.5rem;
        font-size: 1rem;
        color: #4831D4;
        text-align: center;
    }
    
    /* Hints */
    #hintText {
        position: absolute;
        bottom: 8rem;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(72, 49, 212, 0.8);
        color: #CCF381;
        padding: 0.5rem 1rem;
        border-radius: 1rem;
        font-size: 0.9rem;
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 25;
    }
    
    /* Image quality info */
    #imageQualityInfo {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        background-color: rgba(0,0,0,0.7);
        padding: 0.25rem 0.5rem;
        border-radius: 0.5rem;
        font-size: 0.7rem;
        color: #cccccc;
        z-index: 10;
    }
    
    /* Camera switch button */
    #cameraSwitchBtn {
        position: absolute;
        top: 5rem;
        right: 1rem;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: rgba(0,0,0,0.5);
        border: none;
        color: #ffffff;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 15;
    }
    
    /* Debug console */
    #debugConsole {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 150px;
        background-color: rgba(0,0,0,0.9);
        color: #00ff00;
        font-family: monospace;
        font-size: 0.7rem;
        padding: 0.5rem;
        overflow-y: auto;
        z-index: 1000;
        display: none;
    }
    
    /* Gallery section */
    #gallerySection {
        position: absolute;
        top: 5rem;
        left: 1rem;
        right: 1rem;
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto;
        padding: 0.5rem;
        background-color: rgba(0,0,0,0.3);
        border-radius: 0.5rem;
        z-index: 10;
        scrollbar-width: none;
    }
    
    #gallerySection::-webkit-scrollbar {
        display: none;
    }
    
    /* Shutter effect animation */
    .shutter-effect {
        animation: shutter 0.5s;
    }
    
    @keyframes shutter {
        0% { opacity: 1; }
        50% { opacity: 0; }
        100% { opacity: 1; }
    }
    
    /* Utility classes */
    .hidden {
        display: none !important;
    }
    
    /* Photo Modal */
    #photoModal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    
    #modalFullImg {
        max-width: 95%;
        max-height: 80%;
        object-fit: contain;
    }
    
    .modal-actions {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
    }
    
    .modal-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: #4831D4;
        color: #CCF381;
        border: none;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    
    #modalCloseBtn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background-color: rgba(255,255,255,0.2);
    }
</style>
</head>
<body>
    <div class="container">
        <!-- Authentication Section -->
        <div id="authSection" class="hidden">
            <div class="auth-logo">PixCrab</div>
            <div class="auth-message">Sync photos with friends in real-time</div>
            <div class="auth-buttons">
                <button id="googleSignIn" class="auth-btn">
                    <svg width="24" height="24" viewBox="0 0 24 24" class="mr-2">
                        <path fill="currentColor" d="M12.24 10.285V14.4h6.806c-.275 1.765-2.056 5.174-6.806 5.174-4.095 0-7.439-3.389-7.439-7.574s3.345-7.574 7.439-7.574c2.33 0 3.891.989 4.785 1.849l3.254-3.138C18.189 1.186 15.479 0 12.24 0c-6.635 0-12 5.365-12 12s5.365 12 12 12c6.926 0 11.52-4.869 11.52-11.726 0-.788-.085-1.39-.189-1.989H12.24z"/>
                    </svg>
                    Continue with Google
                </button>
                <button id="appleSignIn" class="auth-btn">
                    <svg width="24" height="24" viewBox="0 0 24 24" class="mr-2">
                        <path fill="currentColor" d="M17.05 20.28a9.85 9.85 0 0 1-.98 1.8c-.52.74-1.05 1.32-1.59 1.74-.85.7-1.73 1.06-2.64 1.07-68 0-1.5-.19-2.45-.58-96-.39-1.83-.58-2.63-.58-.83 0-1.73.2-2.71.6-.97.39-1.8.59-2.48.59s-1.52-.2-2.46-.61c-.95-.4-1.73-.61-2.35-.63-.9-.03-1.8-.38-2.68-1.06-.58-.44-1.16-1.04-1.73-1.81a11.2 11.2 0 0 1-1.21-2.27c-.41-.94-.73-2.03-.98-3.25-.27-1.3-.4-2.64-.4-4.01 0-1.6.34-3 1.03-4.2.54-.95 1.26-1.7 2.17-2.27.9-.57 1.9-.86 2.99-.88.6 0 1.37.12 2.33.35.95.23 1.56.35 1.84.35.2 0 .88-.14 2.05-.42 1.1-.25 2.02-.36 2.78-.33 2.06.16 3.6.95 4.63 2.38-1.84 1.12-2.75 2.69-2.75 4.7 0 1.57.58 2.87 1.72 3.9.52.5 1.09.89 1.73 1.18-.14.4-.28.79-.44 1.16zM12.92.02c0 .23-.02.47-.05.7-.04.24-.1.5-.19.75-.33 1.07-.9 1.99-1.72 2.75-.93.81-1.9 1.21-2.9 1.15-.05-.42-.08-.82-.08-1.2 0-.27.03-.57.09-.91.05-.34.14-.67.26-1 .12-.32.28-.63.48-.92.2-.3.4-.55.62-.75.22-.2.48-.4.76-.58.28-.18.52-.31.74-.39.22-.08.5-.16.83-.23.33-.07.58-.1.76-.11h.32z"/>
                    </svg>
                    Continue with Apple
                </button>
                <button id="guestSignIn" class="auth-btn">
                    <svg width="24" height="24" viewBox="0 0 24 24" class="mr-2">
                        <path fill="currentColor" d="M12 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
                    </svg>
                    Continue as Guest
                </button>
            </div>
        </div>
        
        <!-- Session Setup Section -->
        <div id="sessionSetup" class="hidden">
            <div class="session-logo">PixCrab</div>
            <div class="session-message">Capture photos with friends in perfect sync</div>
            <div class="session-input">
                <input type="text" id="sessionId" placeholder="Enter Session ID" maxlength="10">
                <button id="joinSession" disabled>Join</button>
            </div>
            <button id="createSession" disabled>Create New Session</button>
            <p class="text-sm text-gray-300">Share the session ID with a friend to sync photos</p>
            
            <button id="signOutBtn">Sign Out</button>
        </div>
        
        <!-- Camera Section -->
        <div id="cameraSection" class="hidden">
            <div class="camera-header">
                <div class="session-badge" id="sessionIdBadge">
                    <span id="displaySessionId"></span>
                    <svg xmlns="http://www.w3.org/2000/svg" class="ml-1" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                </div>
                <div class="camera-status">
                    <div id="connectionStatus" class="w-3 h-3 rounded-full status-disconnected mr-2"></div>
                    <span id="statusText">Disconnected</span>
                    <span class="mx-2">|</span>
                    <span id="peerCount">0 peers connected</span>
                </div>
            </div>
            
            <div id="slideContainer">
                <div class="slide">
                    <div class="camera-feed-container">
                        <video id="cameraFeed" autoplay playsinline></video>
                        <img id="photoResult" alt="Photo result">
                        
                        <div id="countdownOverlay" class="hidden">
                            <div id="countdownText" class="hidden">3</div>
                            <div id="captureText" class="hidden">Snap!</div>
                        </div>
                        
                        <button id="cameraSwitchBtn" class="hidden">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7"></path>
                                <line x1="16" y1="5" x2="22" y2="5"></line>
                                <line x1="19" y1="2" x2="19" y2="8"></line>
                                <circle cx="9" cy="9" r="3"></circle>
                                <path d="M13 13L9 9"></path>
                            </svg>
                        </button>
                        
                        <div id="qrcode" class="hidden"></div>
                        <div id="qrFallback" class="hidden"></div>
                        
                        <div id="hintText">Swipe up to view photos</div>
                        
                        <div id="gallerySection" class="hidden"></div>
                        
                        <div id="imageQualityInfo" class="hidden">
                            <span id="imageSize">0</span> KB
                        </div>
                    </div>
                    
                    <div class="camera-controls">
                        <button id="newSessionBtn">Exit</button>
                        <button id="captureBtn" disabled></button>
                        <div class="w-20"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Toast Notification -->
        <div id="toast" class="hidden"></div>
        
        <!-- Photo Modal -->
        <div id="photoModal" class="hidden">
            <button id="modalCloseBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            <img id="modalFullImg" src="" alt="Full size photo">
            <div class="modal-actions">
                <button id="modalDownloadBtn" class="modal-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
                <button id="modalShareBtn" class="modal-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="18" cy="5" r="3"></circle>
                        <circle cx="6" cy="12" r="3"></circle>
                        <circle cx="18" cy="19" r="3"></circle>
                        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                    </svg>
                </button>
            </div>
        </div>
        
        <!-- Debug Console -->
        <div id="debugConsole"></div>
        <button id="debugToggle" style="position: fixed; bottom: 10px; right: 10px; width: 30px; height: 30px; background: rgba(0,0,0,0.5); border: none; color: white; border-radius: 50%; z-index: 1000; display: flex; justify-content: center; align-items: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="4 17 10 11 4 5"></polyline>
                <line x1="12" y1="19" x2="20" y2="19"></line>
            </svg>
        </button>
    </div>
    
    <script>
// ... rest of the script ...
    </script>
</body>
</html>
